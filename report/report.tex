\documentclass{article}

\usepackage{upgreek}

\usepackage{parskip}

\sloppy

\usepackage{amsmath} % actually amsopn
\makeatletter
\DeclareRobustCommand{\var}[1]{\begingroup\newmcodes@\mathit{#1}\endgroup}
\makeatother
\makeatletter
\DeclareRobustCommand{\varb}[1]{\begingroup\newmcodes@\mathbf{#1}\endgroup}
\makeatother

\usepackage{amsfonts}

\usepackage[a4paper, margin=1in]{geometry}

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\chevrons{\langle}{\rangle}

\usepackage{graphicx}
\graphicspath{{./}}

\usepackage{color}

\definecolor{hyperref}{rgb}{0, 0, 0.4}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	urlcolor=hyperref,
	}

\newcommand{\n}{\ \-}

\usepackage{enumitem}

\usepackage[style=ieee]{biblatex}
\addbibresource{refs.bib}

\usepackage{algorithm}
\usepackage{algpseudocode}

\MakeRobust{\Call}

\begin{document}

\section*{Introduction}

This report outlines and analyses an implementation of a parallel algorithm for the following
problem:\\
Given a grid, where each square has a positive integer as its cost, find the shortest 8 connected
path from the top left most square to the bottom right most square, where the distance of a path is
defined as the sum of costs of all squares on the path.

The algorithm I've devised is a modified version of the delta stepping algorithm from Mayer and
Sanders \cite{Meyer-1998}, described in the algorithm 1 with its functions in algorithm 2.
\begin{algorithm}
	\caption{}
	\begin{algorithmic}[1]
		\State \(x_{end}\gets x_{size} - 1\)
		\State \(y_{end}\gets y_{size} - 1\)

		\State \(delta\gets \Call{FindDelta}{ }\)
		\For{\(x \gets 0\) \textbf{to} \(x_{end}\)}\textbf{ in parallel}
			\For{\(y \gets 0\) \textbf{to} \(y_{end}\)}\textbf{ in parallel}
				\State $distance[x][y] \gets \infty$
				\State $bmap[x][y] \gets -1$ \Comment{bmap map (x, y) to the which b[i] set they're
				in, hence speeding up the \textsc{Remove}.}
			\EndFor
		\EndFor

		\State \(distance[0][0]\gets \Call{Cost}{0, 0}\)
		\State \Call{Insert}{0, 0}

		\State $i_{dest} \gets \infty$
		\State $removed \gets \emptyset$
		\State $relaxed \gets \emptyset$

		\State $i \gets 0$
		\While{$i < i_{dest}$}
			\While{b[i] is not empty}
				\State \Call{Relax}{b[i], relaxed, removed}
				\State $b[i] \gets \emptyset$
				\For{$\textbf{each} (x, y) \in relaxed$} \textbf{in parallel}
					\State \Call{Insert}{x, y}
					\If{$ x_{end} = x \land y_{end} = y $}
						\State $i_{dest} \gets i$
					\EndIf
				\EndFor
			\EndWhile
			\State $relaxed \gets \emptyset$
			\State $removed \gets \emptyset$
		\EndWhile

		\State $x \gets x_{end}$ \Comment{Reconstruct the path from distance.}
		\State $y \gets y_{end}$
		\State $path \gets [ ]$
		\While{$x \ne 0 \land y \ne 0$}
			\State $x_{pred} \gets x$
			\State $y_{pred} \gets y$
			\For{\(dx \gets -1, 0, 1\)}
				\For{\(dy \gets -1, 0, 1\)}
			\State $x_{new} \gets x + dx$
			\State $y_{new} \gets y + dy$
					\If{\((x_{new}, y_{new}) \text{ is valid coordinate} \land (x_{new},
					y_{new}) \ne (x, y)\)}
						\If{$distance[x_{new}][y_{new}] < distance[x_{pred}][y_{pred}]$}
							\State $x_{pred} \gets x_{new}$
							\State $y_{pred} \gets y_{new}$
						\EndIf
					\EndIf
				\EndFor
			\EndFor
			\State $path prepend (x_{pred}, y_{pred})$
		\EndWhile
		\State \Return path
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\caption{Functions of Algorithm 1}
	\begin{algorithmic}[1]
		\Function{FindDelta}{ }
			\For{\(x \gets 0\) \textbf{to} \(x_{end}\)}\textbf{ in parallel}
				\For{\(y \gets 0\) \textbf{to} \(y_{end}\)}\textbf{ in parallel}
					\State \(cost_{max} \gets \Call{Max}{cost_{max}, \Call{Cost}{x, y}}\)
				\EndFor
			\EndFor
			\State \Return \(cost_{max} / 8\)
		\EndFunction
		\Function{Remove}{x, y}
			\If{$bmap[x][y] \ne -1$}
				\State $b[bmap[x][y]] \gets b[bmap[x][y]] \setminus {(x, y)}$
			\EndIf
		\EndFunction
		\Function{Insert}{x, y}
			\State $i \gets \floor{distance[x][y] / delta}$
			\State $bmap[x][y] \gets i$
			\State $b[i] \gets b[i] \cup (x, y)$
		\EndFunction

		\Function{Relax}{to-relax, relaxed, removed} \Comment{pass NULL as removed will cause the
		function to only Relax heavy edges. Pass a set as removed will cause the function to call
		\textsc{Remove} for each coordinate in to-relax and add them to removed.}
			\For{\textbf{each} \((x, y) \in \) to-relax} \textbf{in parallel}
				\If{\(removed \ne NULL\)}
					\State \Call{Remove}{x, y}
					\State \(removed \gets removed \cap (x, y)\)
				\EndIf
				\For{\(dx \gets -1, 0, 1\)}
					\For{\(dy \gets -1, 0, 1\)}
						\State \(x_{next} \gets x + dx\)
						\State \(y_{next} \gets y + dy\)
						\If{\((x_{next}, y_{next}) \text{ is valid coordinate} \land (x_{next},
						y_{next}) \ne (x, y)\)}
							\If{$(\Call{Cost}{x_{next}, y_{next}} \le delta) \oplus (removed =
							NULL)$} \Comment{If removed is null, only relax heavy edges, otherwise
							only relax light edges.}
								\State $distance_{new} \gets distance[x][y] + \Call{Cost}{x_{next},
								y_{next}}$
								\If{$distance_{new} < distance[x_{next}][y_{next}]$}
									\State $distance[x_{next}][y_{next}] \gets distance_{new}$
									\State $relaxed \gets relaxed \cap (x_{next}, y_{next})$
								\EndIf
							\EndIf
						\EndIf
					\EndFor
				\EndFor
			\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Note that \(\Call{Cost}{x, y}\) returns the cost of the cell on \(x_{th}\) row and \(y_{th}\).
Furthermore, while the cost takes a long time to calculate for the first time. This function caches
the cost in a 2D array so subsequence call returns instantly. This has the additional effect of
calculating the cost of each cell upfront in a parallel fashion during the \textsc{FindDelta}
procedure. Not only does this allow delta to be calculated at the optimal value. It also allows the
load of calculating the cost of each cell to be spread evenly among all processors, taking advantage
of parallelization for the most expensive part of the algorithm.

Furthermore, to ensure that $relaxed$ and $removed$ can be queried in constant time as well as being
made emptied in constant time, I implemented them as 2D int arrays where (x, y) is in the set if
$set[x][y] = trueValue$. Here $trueValue$ is an integer. By incrementing $trueValue$ we can empty
the set very quickly.

The implementation of the algorithm is less than ideal. Because I choose to use vector in the C++
standard library, which isn't thread safe, I have to heavily used locking and OpenMP critical
region to ensure data races does not happen. This means the implementation of the algorithm isn't as
parallel as it should be and further improvement on data structures and hence performance can be
made.

\section*{Methodology}
To confirm and measure the performance of my algorithm, I've 

\section*{Experiments}
\section*{Discussion}
\section*{Conclusion}

\printbibliography

\end{document}
